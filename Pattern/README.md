# 漏洞模式整理

1. 使用变量作为数组下标，但是变量可取值的范围超过了数组的 size ，即可以导致越界读或写。
2. 分配一块内存，但内存开始的地址并不是对齐的，后面为了使用对齐的内存，就会在以内存中间对齐的地址开始访问或读写，访问或读写的范围还是原有内存的大小，就会导致越界读或写。
3. 使用无符号数进行运算时，理论上计算得到的值应为负数，但是无符号数没有负数，负数对应一个很大的正数，从而再使用计算得到的结果进行计算时，就可能会导致越界等问题。
4. 进程之间的条件竞争可能会导致程序的执行流程会发生改变，从而引发出不可预计的错误。
5. 当存储数据的 buffer 被填充满的时候，使用strlen 得到的结果可能会是比理想值大的，因为其会把buffer 后面的内容的长度也算进去。
6. 以数组的size 作为下标的时候，会导致读取或写入的时候，读取或写入到数组后面的区间，可读取或写入的长度取决于数组后面的内容的存储类型。
7. 使用snprintf函数，然后格式化字符串为%s，同时有一个变量会存储snprintf的返回值，并且这个返回值后面还会被作为snprintf函数的第二个参数，这样我们就可以控制snprintf往buffer中填的内容的长度，从而达到溢出的效果。
8. 使用有符号整数，但是在使用前的检测中没有对小于 0 部分的检测。
9. TOCTOU 漏洞，在 check 和 use 之间有时间差，利用该时间差修改掉 check 验证成功后的内容 // TODO 。
10. C++ 中类有一个所有对象共用的一个指针，在一个对象释放该指针后，其他对象再使用该指针导致 UAF 。
11. 强制转换结构体变量的类型，因为偏移发生了变换，可能导致 OO 。
12. 错误检测，检测到错误后没有错误处理，而是继续运行。
13. 事件队列，队列中的事件被释放了，但是没有将其删除，导致 UAF 。
14. for 循环中的循环限制条件在循环结束之后还会被使用，容易导致 Off-By-One 。
15. 一个用户可控的整数，会被用来作为下标或者 alloc 分配内存时的 size ，如果在使用这个整数前没有进行检测，可能导致 OO 。
16. Chrome 中重写了 weakptr ， weakptr 的 get 方法会检测成员变量 vaild 的值，如果为空则返回 NULL ，如果在使用 weakptr.get 方法的地方没有对 NULL 进行检测的话就会导致引用一个空指针，并且在开启 O3 优化时可以把这个 Free NULL 漏洞转换成一个 UAF 漏洞。
17. C++ 中在类的成员函数中调用一些外部的函数，外部函数中的某些操作是可能导致 delete this ，从而导致类实例化对象被释放，之后的代码中再使用该对象导致 UAF 。
18. 在 for 循环中若循环条件中会使用循环循环变量的话则必须先对循环变量进行检查，然后再使用他，如果先使用后检查可能导致溢出。
19. 条件竞争漏洞，锁没有保护住应被加锁的资源，用代码举例的话，第 1 行代码是 resource = handle(old_resource)，第 2 行是 lock(resource)，lock 在 resource 被修改之后才分配所以不能确保 resource 不会被修改，正常情况下应该是先写 lock(resource) 然后再写 resource = handle(old_resource)。


