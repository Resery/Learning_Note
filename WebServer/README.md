# Resery's WebServer 技术文档

## RAII 机制

RAII 机制对应的英文为 Resource Acquisition is Initialization，翻译为中文即资源获取即初始化，在 stackoverflow 上查了查 RAII 具体体现在哪些地方

1. RAII 主要的目的是减少麻烦的资源管理，不仅仅是内存的管理，比如说一个文件被打开之后获取到了对应的文件描述符，对应的在结束使用这个文件描述符时应将其关闭，或者一个互斥量锁住之后需要被解开，一个对象需要被释放，一块内存也需要被释放。换句话来说，RAII 就是会帮助你在你使用完资源后做一些必做的事
2. 智能指针也应用到了 RAII 机制，体现在离开了智能指针的作用域之后就会立即调用指针指向的对象的析构函数，来析构掉这个对象的内容，而且指针本身指向的内容也会清空
3. 对象在结束使用时必须被释放也就是调用其析构函数，但是对象在创建时也应该默认的调用其构造函数来完成其成员变量的初始化

## 读取请求与发送响应


## HTTP 状态机解析请求

1. 概述
   此 WebServer 使用主从状态机模式来进行解析，主状态机调用从状态机来读取数据，从状态机根据读取到到数据更新自身的状态，主状态机根据从状态机返回的状态来决定是继续读取数据还是响应请求
2. 主状态机
   主状态机应有 3 种状态，当前正在解析请求行，请求头和请求体
   最开始 HTTPHandler 对象的主状态会被设置为**正在解析请求行状态**，在主状态机内根据主状态判断当前应执行何种动作，也就是首先解析请求行，解析完请求行之后，直接检测是否能支持此次请求以及此次请求是否属于合法状态，因为请求行已经解析完成了所以说应该更新主状态机的状态，解析完请求行就应该解析请求头了，我实现的 WebServer 主要解析是否是长连接以及请求主体的长度，此时对象的主状态为**正在解析请求头状态**，解析完请求头之后，就立即将对象的状态设置为**正在解析请求主体状态**

   在每次状态转换期间，都会根据每次解析之后的结果来进行不同的操作，比如说从**解析请求行状态**转移到**解析请求头状态**期间发现不支持当前的请求方法那么就会直接返回一个错误报文，并且结束此次的连接，再或者说从解析请求行之后发现此次请求不包含报文主体那么就不会进行**解析请求头状态**到**解析请求主体状态**的转移
3. 从状态机
   从状态机应有 3 种状态，读取到完整到一行，没有读完一行和读取发生错误
   从状态机主要是起一个辅助的作用，从状态机并不解析请求报文中的内容仅检测数据是否完整，然后按行读取请求报文，当数据完整且正常时从状态机会返回 LineOk 状态，当数据不完整但正常时从状态机会返回 LineOpen 状态，当数据不正常时从状态机会返回 LineBad 状态，只有当从状态机的状态为 LineOk 状态时主状态机才可以继续工作，如果从状态机的状态为 LineOpen 状态或者 LineBad状态时那么主状态机也会随之终止
4. 为什么使用状态机
   使用状态机主要是可以让开发者的思路变的更为清晰，逻辑更通顺，以及来提升开发的效率，以上为个人见解

## 线程同步机制封装类

线程同步这里采取信号量，管程和条件变量三项技术，并且使用了 RAII 机制封装了与之对应的构造和析构函数

```CPP
#include <pthread.h>
#include <semaphore.h>
#include <exception>

class Sem {
private:
    sem_t sem_;

public:
    Sem() {
        if (sem_init(&sem_, 0, 0) == -1) {
            throw std::exception();
        }
    }

    Sem(int num) {
        if (sem_init(&sem_, 0, num) == -1) {
            throw std::exception();
        }
    };

    ~Sem() {
        sem_destroy(&sem_);
    }

    bool Wait() { return sem_wait(&sem_) == 0; }

    bool Post() { return sem_post(&sem_) == 0; }
};

class Mutex {
public:
    Mutex() {
        if (pthread_mutex_init(&mutex_, NULL) == -1) {
            throw std::exception();
        }
    };

    ~Mutex() {
        if (pthread_mutex_destroy(&mutex_) == -1) {
            throw std::exception();
        }
    }

    bool Lock() { pthread_mutex_lock(&mutex_); }

    bool UnLock() { pthread_mutex_unlock(&mutex_); }

    pthread_mutex_t * Get() { return &mutex_; }

private:
    pthread_mutex_t mutex_;
};

class Condicate {
public:
    Condicate() {
        if (pthread_cond_init(&cond_, NULL) == -1) {
            throw std::exception();
        }
    }

    ~Condicate() {
        if (pthread_cond_destroy(&cond_) == -1) {
            throw std::exception();
        }
    }

    bool Signal() { return pthread_cond_signal(&cond_) == 0; }

    bool Wait(pthread_mutex_t mutex) { return pthread_cond_wait(&cond_, &mutex) == 0;}

    bool TimeWait(pthread_mutex_t mutex, struct timespec time) {
        return pthread_cond_timedwait(&cond_, &mutex, &time) == 0;
    }

    bool broadcast() { return pthread_cond_broadcast(&cond_) == 0; }

private:
    pthread_cond_t cond_;
};
```

## 线程池

WebServer 的主要框架由 IO 处理单元与逻辑单元组成，其中 IO 处理单元除要负责客户端的连接以及处理套接字相关的读写工作，逻辑单元除要负责逻辑部分也就是解析 http 包并生成响应报文的工作

一共有 5 中 IO 模型
1. 阻塞 IO
   阻塞 IO 顾名思义也就是说在调用一个函数之后会一直等待该函数返回，如果该函数没有返回那么会一直检测这个函数是否返回，直到函数返回后才会进行后续的工作
2. 非阻塞 IO
   非阻塞 IO 顾名思义也就是说会每隔一段时间去检测 IO 事件是否就绪，如果没有处于就绪状态那么就可以做其他事情，非阻塞 IO 执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回 -1，此时可以根据 errno 来判断这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain
3. 信号驱动 IO
   信号驱动 IO 就是会注册一个信号处理函数，当没有出现对应的 IO 信号那么进行就会继续运行但不阻塞，如果出现了对应的 IO 信号那么就会去执行对应的 IO 动作
4. IO 复用
   IO 复用简单的来说就是可以让一个进程处理多个文件描述符，select 和 poll 实现的 IO 复用差别不大，唯一的差别就是 select 检测描述符的数量有限制但是 poll 是没有的，select 和 poll 是需要将想要检测的文件描述符添加到对应的集合中，一共分为三个集合，读集合，写集合和错误集合，然后当有文件描述符处于就绪状态时函数就会返回，接着轮询三个集合即可找到处于就绪状态的文件描述符。除了 select 和 poll 还有一种实现 IO 复用的方式就是 epoll，epoll 会在内核中创建一个 epoll 对象，然后会创建一个 interest list，这个链表是用红黑树来存储的，我们需要将想要检测的文件描述符添加到 interest list 链表中，如果检测到被检测的描述符指定的事件发生，那么会将其放入一个 ready list 链表中，该链表使用双向队列来存储，我们只需要在 epoll_wait 函数返回后遍历 ready_list 链表就可以处理对应的事件了

   3 种 IO 复用模式各有利弊，具体的比较不再罗列，更多的内容会放在我的 WebServer 仓库中
5. 异步 IO
   在 Linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

事件处理模式

Reactor 模式下主线程主要负责处理连接相关的工作，工作线程负责处理 IO 读写操作以及逻辑相关的问题，通常由同步 IO 完成

Proactor 模式下主线程主要负责处理连接和 IO 读写相关的工作，工作线程负责处理逻辑相关的问题，通常有异步 IO 完成

同步 IO 模拟 Proactor 模式主要的流程如下

1. 主线程创建 epoll 对象并将要检测的文件描述符和想要检测的事件添加到 interest list 中
2. 主线程调用 epoll_wait 等待有文件描述符发生对应的读事件
3. 当有文件描述符处于可读状态，主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个对象添加到请求队列中
4. 睡眠在请求队列上的某个工作线程被唤醒，进行响应的逻辑处理操作，处理完成后告知主线程该文件描述符现在处于可写状态
5. 主线程调用 epoll_wait 等待有文件描述符发生对应的写事件
6. 当有文件描述符处于可写状态，主线程往其中写入数据

半同步/半反应堆模式的工作流程

- 同步线程主要用来处理逻辑操作
- 异步线程主要用来处理 IO 事件
- 异步线程在接收到连接请求后，能将其封装成对象插入到请求队列中
- 请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对j

**tips:**并发模式中的同步指的是程序完全按照代码序列的顺序执行，异步指的是程序的执行需要由系统事件驱动

半同步/半反应堆工作流程（以Proactor模式为例）

1. 主线程充当异步线程，负责监听所有socket上的事件
2. 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
3. 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
4. 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

有了上述的前置之后，我们就需要思考一下线程池应该包含哪些元素，并且线程池应该支持哪些操作

线程池的实现

1. 最简单的线程池也应该支持创建销毁线程池的功能，以及添加任务这三项基本的功能
2. 要实现上面的功能需要几种数据结构来进行支撑，一个用来存储线程信息的线程数组，一个链表用来表示请求队列
3. 为了保证操作的原子性即需要管程、信号量还有条件变量的支持
4. 同时也需要模版的支持，模版可以使得我们能够往工作线程中添加 HTTPHandler 类型的变量

实现了线程池之后目前也就可以处理并发的请求了，使用了 ab 测试在并发数为 100，总共请求 10000 次的情况下，全部完成总共花费了 2.743 秒

现在来具体介绍线程池中的四个函数，主要就是 Worker 函数，Run 函数，以及 Append 函数，以及构造函数

1. 构造函数
   构造函数会首先检测一下创建的线程数超没超过最大线程数，如果其数量超过了最大线程数，那么就会抛出一个异常，过了检测之后就直接根据指定的线程数来创建线程，并将所有线程置于分离状态
2. Worker 函数
   Worker 函数有一个要点需要注意，就是因为 C++ 为了实现虚函数等机制，会在调用函数时自动将第一个参数设置为 this，但是我们在调用 pthread_create 创建线程时，需要提前指明想要传递给线程函数的参数，但是如果说 pthread_create 函数里对应的参数填写的不是 this 的话，那么这个参数会直接被丢弃，也就是接受不到，所以说这里 Worker 应该接受什么样的参数应该需要提前设想好
3. Run 函数
   Run 函数首先检测信号量上时候有事件被挂起，如果有的话那么就可以执行后续的操作了，后面的操作也不是很难，就是从请求队列中取出第一个元素，然后将其从队列中函数然后调用这个元素（元素类型为 HTTPHandler）的主状态机方法，之后就继续循环等待就可以了
4. Append 函数
   Append 函数是在主线程中被调用的，每次接收到一连接请求后，主线程先进行读操作，读完之后就调用线程池中的 Append 函数将此次连接对应的 HTTPHandler 对象作为参数传入到 Append 函数中，因为是创建一个子线程来处理逻辑与发送，所以主线程可以继续去检测是否有新的连接到来

## 计时器
